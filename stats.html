<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ethernova — Network Stats</title>
  <style>
    :root{
      --bg:#070a12; --card:#0f1630; --border:#26335b; --text:#eaf0ff; --muted:#a9b6da;
      --good:#30d158; --warn:#ffd60a; --bad:#ff453a;
    }
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;background:radial-gradient(1200px 800px at 20% 10%, #111a3a 0%, var(--bg) 55%);color:var(--text);}
    header{padding:28px 18px 10px;max-width:1100px;margin:0 auto;}
    h1{margin:0;font-size:28px;letter-spacing:.2px}
    .sub{color:var(--muted);margin-top:6px}
    .wrap{max-width:1100px;margin:0 auto;padding:14px 18px 30px;}
    .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(230px,1fr));gap:12px;margin-top:14px;}
    .card{background:linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));border:1px solid var(--border);border-radius:16px;padding:14px 14px 12px;box-shadow:0 10px 30px rgba(0,0,0,.25);}
    .label{font-size:12px;color:var(--muted);margin-bottom:7px}
    .value{font-size:22px;font-weight:750;line-height:1.15;word-break:break-word}
    .tiny{font-size:12px;color:var(--muted);margin-top:10px}
    .row{display:flex;gap:10px;align-items:center;justify-content:space-between;flex-wrap:wrap}
    .pill{display:inline-flex;align-items:center;gap:8px;border:1px solid var(--border);border-radius:999px;padding:7px 10px;background:rgba(255,255,255,.02);color:var(--muted);font-size:12px}
    .dot{width:10px;height:10px;border-radius:50%}
    a{color:#9fc1ff;text-decoration:none} a:hover{text-decoration:underline}
    .btn{cursor:pointer;border:1px solid var(--border);background:rgba(255,255,255,.03);color:var(--text);padding:8px 10px;border-radius:10px;font-size:12px}
    select.btn{padding:8px 10px}
    .controls{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .chartCard{margin-top:12px}
    .chartWrap{margin-top:10px;height:440px}
    canvas{width:100% !important;height:100% !important;display:block}
    .toggles{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
    .toggle{display:flex;gap:8px;align-items:center;border:1px solid var(--border);border-radius:999px;padding:6px 10px;background:rgba(255,255,255,.02);font-size:12px;color:var(--muted)}
    .toggle input{transform:translateY(1px)}
    .split{display:grid;grid-template-columns:1fr;gap:12px;margin-top:12px}
  </style>
</head>
<body>

<header>
  <div class="row">
    <div>
      <h1>🌌 Ethernova Network Stats</h1>
      <div class="sub">Live data from <a href="https://api.ethnova.net/stats.json" target="_blank" rel="noreferrer">api.ethnova.net</a></div>
    </div>
    <div class="pill">
      <span class="dot" id="healthDot" style="background:var(--warn)"></span>
      <span id="healthText">Loading…</span>
    </div>
  </div>
</header>

<div class="wrap">

  <div class="grid">
    <div class="card"><div class="label">Client Version</div><div class="value" id="clientVersion">-</div><div class="tiny" id="clientVersionFull">Full: -</div></div>
    <div class="card"><div class="label">Latest Block</div><div class="value" id="latestBlock">—</div><div class="tiny">Source: eth_blockNumber</div></div>
    <div class="card"><div class="label">Total Supply (NOVA)</div><div class="value" id="minedCoins">-</div><div class="tiny" id="supplyNote">Supply includes migration baseline.</div></div>
    <div class="card"><div class="label">Ethash Epoch</div><div class="value" id="ethashEpoch">-</div><div class="tiny" id="dagSize">Est. DAG size: -</div><div class="tiny" id="nextEpochEta">Next epoch in: -</div><div class="tiny" id="nextEpochBlocks">Blocks remaining: -</div></div>
    <div class="card"><div class="label">Gas Price (Gwei)</div><div class="value" id="gasPriceGwei">—</div><div class="tiny">Source: eth_gasPrice</div></div>
    <div class="card"><div class="label">Avg Block Time (sec)</div><div class="value" id="avgBlockTimeSec">—</div><div class="tiny" id="avgBlockTimeNote">Average of last 50 blocks • During network halts/fork incidents, block-time is shown as halted and chart points are omitted/capped.</div></div>
    <div class="card"><div class="label">TPS</div><div class="value" id="tps">—</div><div class="tiny">Approx. last 50 blocks</div></div>
    <div class="card"><div class="label">Pending + Queued Tx</div><div class="value" id="pendingTx">-</div><div class="tiny" id="pendingTxNote">txpool_status pending + queued (internal RPC)</div></div>
    <div class="card"><div class="label">Chain Data (GB)</div><div class="value" id="chainDataGB">-</div><div class="tiny">Measured on VPS disk</div></div>
    <div class="card"><div class="label">Network Hashrate (GH/s)</div><div class="value" id="networkHashrateGHs">-</div><div class="tiny">Estimated from difficulty / block time</div></div>
    <div class="card"><div class="label">Avg Difficulty (G)</div><div class="value" id="avgDifficulty">-</div><div class="tiny" id="avgDifficultyRaw">Raw: -</div></div>
    <div class="card"><div class="label">Latest Difficulty (G)</div><div class="value" id="latestDifficulty">-</div><div class="tiny" id="latestDifficultyRaw">Raw: -</div></div>
    <div class="card"><div class="label">Last Update</div><div class="value" id="updatedAt">-</div><div class="tiny">Auto refresh every 5 min</div></div>
  </div>

  <div class="split">
    <div class="card">
      <div class="label">Next Halving (estimate)</div>
      <div class="value" id="halvingMain">—</div>
      <div class="tiny" id="halvingSub">Uses avgBlockTimeSec + remaining blocks. ETA shown in UTC.</div>
    </div>

    <div class="card chartCard">
      <div class="row">
        <div>
          <div class="label">Chart</div>
          <div class="tiny">Pick one or show all lines. Range controls which history file is loaded.</div>
          <div class="tiny" id="dagChartNote">DAG is epoch-derived (30,000 blocks/epoch).</div>
        </div>
        <div class="controls">
          <select id="range" class="btn" title="Range">
            <option value="all">All time</option>
            <option value="1y">Last year</option>
            <option value="6m">6 months</option>
            <option value="3m">3 months</option>
            <option value="1m" selected>Last month</option>
            <option value="1w">One week</option>
          </select>
          <button class="btn" id="btnAll">All</button>
          <button class="btn" id="btnNone">None</button>
          <button class="btn" id="btnRefresh">↻ Refresh</button>
        </div>
      </div>

      <div class="toggles" id="toggleRow"></div>

      <div class="chartWrap">
        <canvas id="chart"></canvas>
      </div>
      <div class="tiny" id="err" style="margin-top:10px"></div>
    </div>
  </div>

</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
<script src="stats-config.js"></script>
<script>
  const STATS_URL = "https://api.ethnova.net/stats.json";
  const HIST_URL = (range) => `https://api.ethnova.net/history-${range}.json`;

  const $ = (id) => document.getElementById(id);

  const CONFIG = window.ETHNOVA_STATS_CONFIG || {};
  const MIGRATION_START_BLOCK = Number(CONFIG.MIGRATION_START_BLOCK);
  const MIGRATION_BASELINE_SUPPLY = Number(CONFIG.MIGRATION_BASELINE_SUPPLY);
  const MIGRATION_START_ISO = typeof CONFIG.MIGRATION_START_ISO === "string" ? CONFIG.MIGRATION_START_ISO : "";
  const MIGRATION_START_MS = MIGRATION_START_ISO ? Date.parse(MIGRATION_START_ISO) : Number.NaN;
  const MAX_BLOCK_TIME_SEC = Number(CONFIG.MAX_BLOCK_TIME_SEC) || 600;

  const ETHASH_EPOCH_LENGTH = 30000;
  const HALT_NOTE = "During network halts/fork incidents, block-time is shown as halted and chart points are omitted/capped.";
  const MOCK_HALT = new URLSearchParams(window.location.search).get("mockHalt") === "1";
  const DAG_BYTES_INIT = 1073741824;
  const DAG_BYTES_GROWTH = 8388608;

  const storage = {
    get(k, fallback){ try{ const v = localStorage.getItem(k); return v ? JSON.parse(v) : fallback; } catch { return fallback; } },
    set(k, v){ try{ localStorage.setItem(k, JSON.stringify(v)); } catch {} }
  };

  function fmtNum(x, digits=2){
    if (x === null || x === undefined) return "-";
    const n = Number(x);
    if (Number.isNaN(n)) return "-";
    return n.toLocaleString(undefined, {
      maximumFractionDigits: digits,
      minimumFractionDigits: digits === 4 ? 4 : 0
    });
  }

  function parsePositiveNumber(value){
    const n = Number(value);
    if (!Number.isFinite(n) || n <= 0) return null;
    return n;
  }

  function blockTimeState(value){
    const n = parsePositiveNumber(value);
    if (n === null) return { value: null, halted: true, reason: "data unavailable" };
    if (n > MAX_BLOCK_TIME_SEC) return { value: null, halted: true, reason: "network halted" };
    return { value: n, halted: false, reason: "" };
  }

  function clampBlockTimeForChart(value){
    const n = parsePositiveNumber(value);
    if (n === null) return null;
    if (n > MAX_BLOCK_TIME_SEC) return null;
    return n;
  }

  function formatPendingTx(value){
    if (value === null) return "disabled";
    const n = Number(value);
    if (!Number.isFinite(n)) return "-";
    return n.toLocaleString();
  }

  function shouldApplyMigration(iso){
    if (!Number.isFinite(MIGRATION_BASELINE_SUPPLY) || MIGRATION_BASELINE_SUPPLY <= 0) return false;
    if (!Number.isFinite(MIGRATION_START_MS)) return false;
    if (!iso) return false;
    const t = Date.parse(iso);
    if (Number.isNaN(t)) return false;
    return t >= MIGRATION_START_MS;
  }

  function supplyWithBaseline(mined, iso){
    const n = Number(mined);
    if (!Number.isFinite(n)) return null;
    if (!shouldApplyMigration(iso)) return n;
    return n + MIGRATION_BASELINE_SUPPLY;
  }

  function setSupplyNote(){
    const note = $("supplyNote");
    if (!note) return;
    if (Number.isFinite(MIGRATION_START_BLOCK)) {
      note.textContent = `Supply includes migration baseline from legacy chain at block ${MIGRATION_START_BLOCK.toLocaleString()}.`;
    } else {
      note.textContent = "Block rewards (1..latest)";
    }
  }

  function estimateDagGiB(epoch){
    if (!Number.isFinite(epoch) || epoch < 0) return null;
    const bytes = DAG_BYTES_INIT + DAG_BYTES_GROWTH * epoch;
    return bytes / (1024 * 1024 * 1024);
  }

  function heightFromMined(minedValue){
    const total = Number(minedValue);
    if (!Number.isFinite(total) || total < 0) return null;
    let remaining = total;
    let height = 0;
    for (let i = 0; i < REWARD_SCHEDULE.length; i++) {
      const seg = REWARD_SCHEDULE[i];
      const start = seg.start;
      const reward = seg.reward;
      const startEff = Math.max(1, start);
      const nextStart = i + 1 < REWARD_SCHEDULE.length ? REWARD_SCHEDULE[i + 1].start : Number.POSITIVE_INFINITY;
      const end = Number.isFinite(nextStart) ? nextStart - 1 : Number.POSITIVE_INFINITY;
      const segmentLen = Number.isFinite(end) ? Math.max(0, end - startEff + 1) : Number.POSITIVE_INFINITY;
      const segmentMined = segmentLen * reward;
      if (!Number.isFinite(segmentMined) || remaining <= segmentMined + 1e-9) {
        if (reward <= 0) return null;
        height = startEff - 1 + remaining / reward;
        return Math.max(0, Math.floor(height));
      }
      remaining -= segmentMined;
      height = end;
    }
    return Math.max(0, Math.floor(height));
  }

  function blockHeightFromPoint(p){
    if (!p || typeof p !== "object") return null;
    const directFields = ["height", "block", "blockHeight", "latestBlock", "h"];
    for (const key of directFields) {
      if (p[key] === null || p[key] === undefined) continue;
      const n = Number(p[key]);
      if (Number.isFinite(n) && n >= 0) return Math.floor(n);
    }
    if (p.mined !== null && p.mined !== undefined) {
      return heightFromMined(p.mined);
    }
    return null;
  }

  function dagFromPoint(p){
    const height = blockHeightFromPoint(p);
    if (!Number.isFinite(height)) return null;
    const epoch = Math.floor(height / ETHASH_EPOCH_LENGTH);
    return estimateDagGiB(epoch);
  }

  function formatDurationShort(seconds){
    const total = Math.round(Number(seconds));
    if (!Number.isFinite(total) || total <= 0) return "-";
    const days = Math.floor(total / 86400);
    const hours = Math.floor((total % 86400) / 3600);
    const mins = Math.floor((total % 3600) / 60);
    const secs = total % 60;
    const parts = [];
    if (days) parts.push(`${days}d`);
    if (hours || (days && mins)) parts.push(`${hours}h`);
    if (mins || (!days && !hours)) parts.push(`${mins}m`);
    if (!days && !hours && mins < 1) parts.push(`${secs}s`);
    return parts.slice(0, 2).join(" ");
  }

  function setEthashStats(latestBlock, btState){
    const height = Number(latestBlock);
    const epochEl = $("ethashEpoch");
    const dagEl = $("dagSize");
    const etaEl = $("nextEpochEta");
    const blocksEl = $("nextEpochBlocks");
    if (!epochEl || !dagEl || !etaEl || !blocksEl) return;
    if (!Number.isFinite(height)) {
      epochEl.textContent = "-";
      dagEl.textContent = "Est. DAG size: -";
      etaEl.textContent = "Next epoch in: -";
      blocksEl.textContent = "Blocks remaining: -";
      return;
    }
    const epoch = Math.floor(height / ETHASH_EPOCH_LENGTH);
    epochEl.textContent = epoch.toLocaleString();
    const dagGiB = estimateDagGiB(epoch);
    dagEl.textContent = Number.isFinite(dagGiB)
      ? `Est. DAG size: ${fmtNum(dagGiB, 2)} GB`
      : "Est. DAG size: -";

    const nextStart = (epoch + 1) * ETHASH_EPOCH_LENGTH;
    const remaining = Math.max(0, nextStart - height);
    blocksEl.textContent = `Blocks remaining: ${remaining.toLocaleString()}`;

    if (remaining <= 0) {
      etaEl.textContent = "Next epoch: imminent";
      return;
    }

    const avgSec = btState && Number.isFinite(btState.value) ? btState.value : null;
    if (!avgSec || (btState && btState.halted)) {
      etaEl.textContent = "ETA: —";
      return;
    }

    const etaSeconds = remaining * avgSec;
    etaEl.textContent = `Next epoch in: ${formatDurationShort(etaSeconds)}`;
  }

  function shortClientVersion(s){
    if (!s || typeof s !== "string") return "-";
    const parts = s.split("/");
    const client = parts[0] || "Client";
    const verPart = parts[1] || "";
    const m = verPart.match(/v\\d+\\.\\d+\\.\\d+/);
    const v = m ? m[0] : verPart;
    return `${client} ${v}`.replace(/\\s+/g, " ").trim();
  }

  function setHealth(updatedAtIso){
    const dot = $("healthDot");
    const txt = $("healthText");
    if (!updatedAtIso) { dot.style.background="var(--warn)"; txt.textContent="No data"; return; }
    const t = Date.parse(updatedAtIso);
    if (Number.isNaN(t)) { dot.style.background="var(--warn)"; txt.textContent="Invalid timestamp"; return; }
    const ageMin = (Date.now() - t) / 60000;
    if (ageMin <= 8) { dot.style.background="var(--good)"; txt.textContent=`OK • updated ${ageMin.toFixed(1)} min ago`; }
    else if (ageMin <= 20) { dot.style.background="var(--warn)"; txt.textContent=`Slow • ${ageMin.toFixed(1)} min ago`; }
    else { dot.style.background="var(--bad)"; txt.textContent=`Stale • ${ageMin.toFixed(1)} min ago`; }
  }

  function labelFor(range, iso){
    if (!iso) return "";
    const d = new Date(iso);
    const Y = d.getUTCFullYear();
    const M = String(d.getUTCMonth()+1).padStart(2,"0");
    const D = String(d.getUTCDate()).padStart(2,"0");
    const hh = String(d.getUTCHours()).padStart(2,"0");
    const mm = String(d.getUTCMinutes()).padStart(2,"0");
    if (range === "1w") return `${hh}:${mm}`;
    if (range === "1m") return `${M}-${D}`;
    if (range === "3m" || range === "6m") return `${M}-${D}`;
    if (range === "1y") return `${Y}-${M}`;
    return `${Y}-${M}`;
  }

  // Halving schedule
  const HALVING_BLOCKS = [2102400, 4204800, 6307200, 8409600];
  function rewardAt(h){
    if (h < 2102400) return 10.0;
    if (h < 4204800) return 5.0;
    if (h < 6307200) return 2.5;
    if (h < 8409600) return 1.25;
    return 1.0;
  }
  const REWARD_SCHEDULE = [
    { start: 0, reward: 10.0 },
    { start: 2102400, reward: 5.0 },
    { start: 4204800, reward: 2.5 },
    { start: 6307200, reward: 1.25 },
    { start: 8409600, reward: 1.0 }
  ];
  function nextHalvingBlock(h){
    for (const b of HALVING_BLOCKS) if (b > h) return b;
    return null;
  }

  function formatUtc(dt){
    // Example: 2025-12-28 04:46 UTC
    const Y = dt.getUTCFullYear();
    const M = String(dt.getUTCMonth()+1).padStart(2,"0");
    const D = String(dt.getUTCDate()).padStart(2,"0");
    const hh = String(dt.getUTCHours()).padStart(2,"0");
    const mm = String(dt.getUTCMinutes()).padStart(2,"0");
    return `${Y}-${M}-${D} ${hh}:${mm} UTC`;
  }

  function setHalving(stats){
    const h = Number(stats.latestBlock);
    const bt = blockTimeState(stats.avgBlockTimeSec);
    const abt = bt.value;
    const updatedAt = stats.updatedAt ? Date.parse(stats.updatedAt) : Date.now();
    const nextB = nextHalvingBlock(h);

    if (!nextB) {
      $("halvingMain").textContent = "No further halvings scheduled";
      $("halvingSub").textContent = "Current reward is the final scheduled tier.";
      return;
    }

    const currentReward = rewardAt(h);
    const nextReward = rewardAt(nextB);
    const remaining = Math.max(0, nextB - h);

    if (!Number.isFinite(abt)) {
      const reason = bt.halted ? (bt.reason || "network halted") : "avgBlockTimeSec missing";
      $("halvingMain").textContent = `Next halving at block ${nextB.toLocaleString()}`;
      $("halvingSub").textContent = `Reward: ${currentReward} → ${nextReward} NOVA • Remaining blocks: ${remaining.toLocaleString()} • ETA unavailable (${reason})`;
      return;
    }

    const etaMs = updatedAt + remaining * abt * 1000;
    const eta = new Date(etaMs);

    const days = (remaining * abt) / 86400;
    $("halvingMain").textContent = `Block ${nextB.toLocaleString()} • ETA ${formatUtc(eta)}`;
    $("halvingSub").textContent =
      `Reward: ${currentReward} → ${nextReward} NOVA • Remaining: ${remaining.toLocaleString()} blocks (~${days.toFixed(1)} days)`;
  }

  const supplyFromPoint = (p) => supplyWithBaseline(p.mined, p.t);

  // Chart datasets (toggleable)
  const METRICS = [
    { key: "avg",    label: "Avg Block Time (sec)", axis: "yAvg",    extract: (p)=>clampBlockTimeForChart(p.avg) },
    { key: "tps",    label: "TPS",                  axis: "yTPS",    extract: (p)=>p.tps },
    { key: "gas",    label: "Gas Price (Gwei)",     axis: "yGas",    extract: (p)=>p.gas },
    { key: "pending",label: "Pending + Queued Tx",  axis: "yPend",   extract: (p)=>p.pending },
    { key: "mined",  label: "Total Supply (NOVA)",  axis: "yMined",  extract: supplyFromPoint },
    { key: "hash",   label: "Network Hashrate (GH/s)", axis: "yHash", extract: (p)=>p.hashrateGHs },
    { key: "diff",   label: "Difficulty (G)",       axis: "yDiff",   extract: (p)=>p.difficultyG },
    { key: "dag",    label: "DAG (GB)",             axis: "yGB",     extract: (p)=>dagFromPoint(p) },
    { key: "chain",  label: "Chain Data (GB)",      axis: "yGB",     extract: (p)=>p.chainDataGB }
  ];

  function defaultSelection(){
    return { avg:true, tps:true, gas:false, pending:false, mined:false, chain:true, dag:true, hash:true, diff:false };
  }

  function makeAxes(selected){
    const axes = {
      x: { ticks: { color: "#a9b6da", maxTicksLimit: 12 }, grid: { color: "rgba(255,255,255,.06)" } }
    };

    // helper to add an axis only if selected
    const addAxis = (id, title, position, offset=false) => {
      axes[id] = {
        position,
        offset,
        ticks: { color: "#a9b6da" },
        grid: { drawOnChartArea: position === "left" }, // only one grid on chart for clarity
        beginAtZero: true,
        title: { display: true, text: title, color: "#a9b6da" }
      };
    };

    if (selected.avg)   addAxis("yAvg",   "sec", "left", false);
    if (selected.tps)   addAxis("yTPS",   "tps", "right", false);
    if (selected.hash)  addAxis("yHash",  "GH/s","right", true);
    if (selected.diff)  addAxis("yDiff",  "Diff (G)", "right", true);
    if (selected.chain || selected.dag) addAxis("yGB", "GB", "right", true);
    if (selected.gas)   addAxis("yGas",   "gwei","right", true);
    if (selected.pending) addAxis("yPend","tx",  "right", true);
    if (selected.mined) addAxis("yMined", "NOVA","right", true);

    return axes;
  }

  function buildToggleUI(selected){
    const row = $("toggleRow");
    row.innerHTML = "";
    for (const m of METRICS) {
      const id = "tg_" + m.key;
      const wrap = document.createElement("label");
      wrap.className = "toggle";
      wrap.innerHTML = `<input type="checkbox" id="${id}"><span>${m.label}</span>`;
      row.appendChild(wrap);
      const cb = wrap.querySelector("input");
      cb.checked = !!selected[m.key];
      cb.addEventListener("change", () => {
        selected[m.key] = cb.checked;
        storage.set("stats_selected", selected);
        renderChart(window.__lastRange, window.__lastHist, selected);
      });
    }
  }

  let chart;

  function renderChart(range, hist, selected){
    if (!hist) return;

    const labels = hist.map(p => labelFor(range, p.t));
    const datasets = [];

    // Assign unique-ish colors so multiple lines are readable
    const colors = {
      avg: "rgba(255, 206, 86, 1)",
      tps: "rgba(54, 162, 235, 1)",
      hash: "rgba(0, 255, 204, 1)",
      diff: "rgba(200, 200, 200, 1)",
      gas: "rgba(153, 102, 255, 1)",
      pending: "rgba(255, 99, 132, 1)",
      mined: "rgba(75, 192, 192, 1)",
      chain: "rgba(255, 159, 64, 1)",
      dag: "rgba(153, 255, 102, 1)"
    };

    for (const m of METRICS) {
      if (!selected[m.key]) continue;
      const data = hist.map(p => {
        const v = m.extract(p);
        if (v === null || v === undefined) return null;
        const n = Number(v);
        return Number.isFinite(n) ? n : null;
      });
      datasets.push({
        label: m.label,
        data,
        yAxisID: m.axis,
        tension: 0.25,
        pointRadius: 0,
        borderWidth: 2,
        spanGaps: m.key !== "avg",
        borderColor: colors[m.key]
      });
    }

    const ctx = $("chart").getContext("2d");
    if (chart) chart.destroy();

    const dpr = Math.max(2, window.devicePixelRatio || 1);

    chart = new Chart(ctx, {
      type: "line",
      data: { labels, datasets },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: false,
        devicePixelRatio: dpr,
        interaction: { mode: "index", intersect: false },
        plugins: { legend: { labels: { color: "#eaf0ff" } } },
        scales: makeAxes(selected)
      }
    });
  }

  async function loadStats(){
    const res = await fetch(STATS_URL, { cache: "no-store" });
    if (!res.ok) throw new Error("Failed to read stats.json (HTTP " + res.status + ")");
    const s = await res.json();
    if (MOCK_HALT) {
      s.avgBlockTimeSec = MAX_BLOCK_TIME_SEC + 1;
    }

    const full = s.clientVersion || "";
    $("clientVersion").textContent   = shortClientVersion(full);
    $("clientVersionFull").textContent = full ? `Full: ${full}` : "Full: -";
    $("latestBlock").textContent     = (s.latestBlock ?? "-");
    const totalSupply = supplyWithBaseline(s.minedCoins, s.updatedAt);
    $("minedCoins").textContent      = fmtNum(totalSupply, 4);
    $("gasPriceGwei").textContent    = fmtNum(s.gasPriceGwei, 2);
    const bt = blockTimeState(s.avgBlockTimeSec);
    $("avgBlockTimeSec").textContent = bt.halted ? "— (network halted)" : fmtNum(bt.value, 2);
    const avgNote = $("avgBlockTimeNote");
    if (avgNote) {
      avgNote.textContent = bt.halted
        ? HALT_NOTE
        : `Average of last 50 blocks • ${HALT_NOTE}`;
      avgNote.title = HALT_NOTE;
    }
    $("tps").textContent             = fmtNum(s.tps, 4);
    $("pendingTx").textContent       = formatPendingTx(s.pendingTx);
    const pendingNote = $("pendingTxNote");
    if (pendingNote) {
      const pendingDisabled = s.pendingTx === null || s.pendingTx === undefined;
      pendingNote.textContent = pendingDisabled
        ? "Disabled (txpool API not enabled on node)."
        : "txpool_status pending + queued (internal RPC)";
    }
    $("chainDataGB").textContent     = fmtNum(s.chainDataGB, 2);
    $("networkHashrateGHs").textContent = s.networkHashrateHuman || fmtNum(s.networkHashrateGHs, 2);
    $("avgDifficulty").textContent   = (s.avgDifficultyG !== null && s.avgDifficultyG !== undefined)
      ? fmtNum(s.avgDifficultyG, 2)
      : "-";
    $("avgDifficultyRaw").textContent = s.avgDifficulty ? `Raw: ${s.avgDifficulty}` : "Raw: -";
    const latestDifficultyG = Number(s.latestDifficulty) / 1e9;
    $("latestDifficulty").textContent = Number.isFinite(latestDifficultyG) ? fmtNum(latestDifficultyG, 2) : "-";
    $("latestDifficultyRaw").textContent = s.latestDifficulty ? `Raw: ${s.latestDifficulty}` : "Raw: -";
    const dateOnly = (s.updatedAt && typeof s.updatedAt === "string" && s.updatedAt.length >= 10) ? s.updatedAt.slice(0, 10) : "-";
    $("updatedAt").textContent       = dateOnly;

    setHealth(s.updatedAt);
    setHalving(s);
    setSupplyNote();
    setEthashStats(s.latestBlock, bt);

    return s;
  }

  async function loadHistory(range){
    const res = await fetch(HIST_URL(range), { cache: "no-store" });
    if (!res.ok) throw new Error(`Failed to read history-${range}.json (HTTP ${res.status})`);
    const hist = await res.json();
    return hist;
  }

  async function refresh(){
    $("err").textContent = "";
    try{
      const range = $("range").value;
      storage.set("stats_range", range);

      await loadStats();
      const hist = await loadHistory(range);

      // stash for quick re-render when toggles change
      window.__lastRange = range;
      window.__lastHist = hist;

      const selected = storage.get("stats_selected", defaultSelection());
      buildToggleUI(selected);

      // If chainDataGB missing from history, keep dataset but it will be gaps (ok)
      renderChart(range, hist, selected);
    }catch(e){
      $("err").textContent = "Error: " + e.message;
      setHealth(null);
    }
  }

  // Init: restore range + selected metrics
  const savedRange = storage.get("stats_range", "1m");
  $("range").value = savedRange;

  $("btnRefresh").addEventListener("click", refresh);
  $("range").addEventListener("change", refresh);

  $("btnAll").addEventListener("click", () => {
    const selected = {};
    for (const m of METRICS) selected[m.key] = true;
    storage.set("stats_selected", selected);
    buildToggleUI(selected);
    renderChart(window.__lastRange, window.__lastHist, selected);
  });

  $("btnNone").addEventListener("click", () => {
    const selected = {};
    for (const m of METRICS) selected[m.key] = false;
    storage.set("stats_selected", selected);
    buildToggleUI(selected);
    renderChart(window.__lastRange, window.__lastHist, selected);
  });

  refresh();
  setInterval(refresh, 5 * 60 * 1000);

  window.addEventListener("resize", () => { if (chart) chart.resize(); });
</script>

</body>
</html>
